Layer와 Layerd구조
  이러한 형태의 구조는 상위레이어일 경우 하위레이어에 의존함
	


네트워크와 네트워킹 개념
  NetWork -> 관계
  NetWorking -> 상호작용
  OSI 7 Layer -> 네트워크에서 개념을 담당함으로 바로 공부하기에는 무리
	TCP/IP 공부 후 OSI 7 Layer을 공부해보자  
  개념과 구현(ex) 연예인 - 박은빈) 상속과 비슷한 느낌



User mode와 Kernel mode
		      Application(Chrome)	App L7
		 			Presentation
 	User mode    File			Session L5
	----------------------------------------------------------
	Kernel mode			Transport(TCP) L4
S/W Driver(하드웨어를 제어하기 위해 필요)	Network(IP) L3
----------------------------------------------------------------------
H/W NIC( network interface card) =랜카드	Data Link(커널의 Driver Hw 일부분)L2
					Physical (Nic) L1


  App에서 kernel mode에 접근하기 위해서는 인터페이스가 필요
  Socekt(File) -> TCP/IP를 추상화시키 인터페이스





OSI 7 Layer와 식별자
			App (HTTP)
			Presentation
 	User mode 	Session (SSL==TLS) L5
	----------------------------------------------------------
	Kernel mode	Transport(TCP, UDP) L4 식별자 port 번호
S/W 			Network(Internet) L3 -> 식별자 : IP 주소
----------------------------------------------------------------------
H/W			Data Link(Ethernet)(유선)->식별자 : MAC주소
			Physical 

	HTTP+Session -> HTTPS

	MAC주소(물리적 주소) : 랜(NIC)의 식별자, 48비트 주소체계
	IP주소: (host) : 인터넷을 사용하는 컴퓨터의 식별자(v4,v6)
	Port 번호 : 분야에 따라 다른 식별자
		  L2 관점 : 인터페이스 (LAN 케이블 단자)
		  L4 관점 : Service
		  L5~7 관점 : Process

	cmd에서 ipconfig /all 명령을 통해 각각의 실제 주소확인 가능
무선 LAN 어댑터 Wi-Fi:

   연결별 DNS 접미사. . . . :
   설명. . . . . . . . . . . . : Intel(R) Dual Band Wireless-AC 8260
   물리적 주소 . . . . . . . . : 00-C2-C6-B6-44-73
   DHCP 사용 . . . . . . . . . : 예
   자동 구성 사용. . . . . . . : 예
   링크-로컬 IPv6 주소 . . . . : fe80::5514:1a48:fd7:58d2%7(기본 설정)
   IPv4 주소 . . . . . . . . . : 192.168.0.13(기본 설정)
   서브넷 마스크 . . . . . . . : 255.255.255.0
   임대 시작 날짜. . . . . . . : 2023년 6월 22일 목요일 오후 4:15:17
   임대 만료 날짜. . . . . . . : 2023년 6월 22일 목요일 오후 8:15:15
   기본 게이트웨이 . . . . . . : 192.168.0.1
   DHCP 서버 . . . . . . . . . : 192.168.0.1
   DHCPv6 IAID . . . . . . . . : 83935942
   DHCPv6 클라이언트 DUID. . . : 00-01-00-01-25-05-3D-92-98-83-89-22-20-73
   DNS 서버. . . . . . . . . . : 111.118.0.1
                                 111.118.0.11
   Tcpip를 통한 NetBIOS. . . . : 사용





DOD(department of defence) 분류
 	User mode 	Application
	----------------------------------------------------------
	Kernel mode	host to host
S/W 			Internet
----------------------------------------------------------------------
H/W			Network Access





Host는 이렇게 외우자
  host : computer + network 네트워크가 연결된 컴퓨터
  host를 지칭하는 크게 두가지

	switch : 네트워크 자체를 이루는 host -> Infra Structure
		Ip주소가 붙는 경우
		Router(네트워크장비), IPS(보안 스위치),
		Tab,Aggregation(관리목적)

	end-point(단말기) : 네트워크 이용주체
	    -> Client, Server, Peer(P2P 통신->서비스제공자이자 이용자)



Switch가 하는 일
  네트워크 -> 고속도로망과 비슷
	출발지 - 교차로(Switch)(인터페이스 선택=switching) - 목적지
		    ㄴ 이정표를 통해 경로 선택 근거를 찾음
   Packet(자동차, L3 단위)
   Switch : 선택하는 근거-> Ip주소 -> L3 switching(Router) 
   Router : 라우터안에 이정표(Router table)가 존재함
	
  ex) Mac 주소에서는 L2 switching, port번호에서는 L4 switching
       HTTP에서는 L7 switching
  
  스위칭에서 고민해야 할 주제는 비용(Matric 값)
			       ㄴ cmd에서 route print로 확인가능
   비용이 낮은쪽으로 이동함





NIC, L2 Frame, LAN 카드 그리고 Mac 주소
  NIC은 흔히 Lan카드, 유/무선 NIC이 있지만 굳이 구별하지 않음
  NIC은 H/W이며 Mac(Media access control)주소를 갖는다
  cf) USB(universial serial bus) 
  네트워크 규모 : WAN > MAN(도시망) > LAN(home규모의 망)

  Frame(1514byte 정도) : L2 레이어에서의 유통단위
  정보 Frame(10KB)
  Frame 구성 :  |Header(도착,출발 주소)|정보|

  유선의 속도 : 1Gbps -> bit / 1GBps -> byte(단위조심)
  광케이블 : 10Gbps




L2 Access switch( 공유기에 연결되는 단자 부분 -> 인터페이스)
  end-point와 직접 연결되는 스위치(Mac 주소를 근거로 스위칭)
  Link-up(케이블이 정상 연결), Link-down (케이블 비정상연결)
  L2 switch에서 상위(L3) 라우터로 열결되는 경우 up-link라고 함



L2 distribution switch
  L2 Access 스위치를 위한 스위치(VLAN 기능을 제공)
pc1 --|----Access switch---- Distribution Switch ----L3 Switch---Internet
pc2 --|                                     |
pc3 --|                              Access Switch
		           |--------|-------|
		         pc4    pc5    pc6
	-> 상위 switch일수록 가격이 높아짐




Lan과 Wan의 경계 그리고 Broadcast(방송주소) != Unicast(효율이 좋음)
			ㄴ 효율이 안좋음
			ㄴ 노이즈가 될 수 있어서 최소화 해야함
  Mac 주소(FF-FF-FF-FF-FF-FF)가 모두 1이면 Broadcast라 함(항상 참)

     LAN(규모)
pc1 --|----Access switch---- Distribution Switch ----L3 Switch---Internet
pc2 --|                                     |
pc3 --|                              Access Switch
		            |--------|-------|
		           pc4    pc5    pc6

 임의의 Pc1이 broadcast를 하게되면 2~6은 통신불가
 뿐만 아니라 여러방향으로 Frame을 쏴 눈덩이처럼 커져 네트워크가 느려짐
  -> BroadCast를 최소화 해야함  
  -> Distibution이 broadcast를 받지 않게(broad범위를 줄임
      하여 pc456은 영향을 안받게 할수 도 있음 cf)456이 필요한 broadcast인 경우도 있어 복잡함
  -> IP 주소상에서는 Broadcast를 수신하는 범위를 잡아줌




네트워크의 규모

			App (HTTP)
			Presentation
 	User mode 	Session (SSL==TLS) 
	----------------------------------------------------------
	Kernel mode	Transport(TCP, UDP)
S/W(Logical ≈  Virtual)	Network(Internet)
----------------------------------------------------------------------
H/W(Physical)		Data Link(Ethernet)
			Physical 

하드웨어 단계의 네트워크(유선)는 물리적, 소포트웨어 단계에서는 실체가 x
IT분야에서 S/W(Logical) 영역을 Virtual이라기도 함
CPU를 주로 Machine이라 하는데
H/W기능인 CPU를 S/W로 구현하게 되면 이릉 Virtual Machine이라 함

아래 규모 정도는 완벽한게 아니라 요령임
LAN의 규모 : 얼추 H/W Layer 범위 정도의 네트워크(완벽한 정의는 아님)
WAN의 규모 : L3 Layer 범위




IPv4주소의 구조 :
			App (HTTP)
			Presentation
 	User mode 	Session (SSL==TLS) 
	----------------------------------------------------------
	Kernel mode	Transport(TCP, UDP)
S/W(Logical ≈  Virtual)	Network(IP) IPv4->32bit = 8bit*4
-------------------------------------------------- --------------------
H/W(Physical)		Data Link(Ethernet)
			Physical 

  192.168.0.09 -> 대체로 공유기 주소( . 사이당 0~255(8bit))
|32bit(networkID).8bit(HostId)|
  IP가 주소를 찾는 원리가 택배와 비슷 
  NetworkId에 해당하는 부분까지 네트워크를 버스에 태워 찾고
  HostId로 세부 주소를 찾아감



L3 Packet(단위 데이터)-> WireShock로 직접 볼 수 있음
  Packet 자체로 L3 IP Packet을 의미함
  Header(주소 : src->des)과 Payload(내용)로 구성됨 (L2 Frame 도 비슷)
  최대 크기는 MTU(Maximum Transmission unit)(대체로 1500byte)


En/Decapsulation(캡슐화,단위화)(보안면에서 직접으로 정보 보이지않음)
  마치 러시아 목각 인형인 것처럼

L2 Frame
 -----------------------------------------------------------------|
 |   L2	|		L2 Payload #1(L3 IP Packet)  | L2 -> Frame
 |	|   --------------------------------------------------- |
 | HEADER|  |    L3	  |        L3 Payload #2 (TCP Segment) |  L3 -> Packet
 |	|   |HEADER|  ----------------------------------------|  
 |	|   |          |  |  L4 Header | L4 Payload #3	 | L4 -> Segment
 |	|   -----------------------------------------------------|
 ------------------------------------------------------------------|
   Payload #3안에 있는 정보부터는 Stream이라함



패킷의 생성,전달,소멸
  택배와 비슷
철수(process)
    |                                                              
 우편(packet) -> 기사(Gateway) -------------------집(host) -> 영희(process)
					 ㄴ영희 이름(port)

			-------------------------------------
			| 	 Process 
			|
			|
			-------------------------------------		
 	User mode 	|   File,Socket(TCP/IP를 추상화한 인터페이스)
	----------------------------------------------------------
	Kernel mode	 TCP
			  IP

S/W(Logical ≈  Virtual)	 Driver
-------------------------------------------------- --------------------
H/W(Physical)		

  프로세스가 Data를 보낼때 File(socket)에 Send(write)함
  -> TCP단계에서 TCP header을 붙힘 (segment화를 함)
  -> IP단계에서 IP header을 붇힘
  -> Driver단계에서 Ethernet 헤더가 붙어 Frame이 됨
  -> Frame을 송신함
  -> L2 Access Switch 를 만나고 라우터 Gateway를 통해 인터넷으로 나감




계층별 데이터 단위
			-------------------------------------
			| 	 Chrome
			|
			|
			-------------------------------------		
 	User mode 	|   Socket -> Stream
	----------------------------------------------------------
	Kernel mode	 TCP     -> Segment MSS(1460 byte)
			  IP       -> Packet MTU(최대크기 1500byte)

S/W(Logical ≈  Virtual)	 Driver  			  ---
------------------------------------------------- -----------------  |
H/W(Physical)	                                           	   | L1~2: Frame						     	   |
						  ----

  Stream은 시작이 있지만 끝을 정의할 수없음( 끝은 Process가 결정함)
                                     ㄴ 크기를 알 수 없음
   Stream이 MSS, MTU보다 커지게 되면 Stream을 분할함(Segmentation)
   Datagram의 경우는 UDP에서 사용되며 Packet과 비슷  




TCP/IP 송수신 구조 

  1.4MB -> 1.4KB 단위 주의 -> 1024배 차이남
  TCP는 연결이 기본적으로 되야함 -> 가정하고 아래 상황 진행


송신(Encapsulation)
  
			-------------------------------------
			| 	
			|	SERVER ( 프로세스별 버퍼)
			|
			-------------------------------------		
 	User mode 	|  File( Socket I/O에 붙은 Buffer)
	----------------------------------------------------------
	Kernel mode	 TCP     
			  IP       

S/W(Logical ≈  Virtual)	 Driver  			    
------------------------------------------------- -------------------- 
H/W(Physical)	             

  HDD,SDD에서 File(Block)을 읽어 프로세스 버퍼 크기에 맞게 분해 복사 후 프로세스 버퍼에 저장함                      	      		
  Process 버퍼값을 복사하여 Socket 버퍼에 저장( Send/Receive)함
  TCP 스텍에서 MSS크기에 맞게 분해(Segementation)하고 번호를 부여함	
  IP에서 segement를 캡슐화하여 Packet을 만듬	
  L2 단계에서 Frame으로 유통됨

  Segement 번호 순으로 송신하는 것이 이상적
        -> 수신자가 번호 순대로 받았는지 확인하기 위해 Ack를 wait함  
        -> 수신자의 소켓 여유공간도 고려해줌(스윗하누)



수신(Decapsulation)
			-------------------------------------
			| 	
			|Chrome
			|
			-------------------------------------		
 	User mode 	|  File( Socket I/O에 붙은 Buffer)
	----------------------------------------------------------
	Kernel mode	 TCP     
			  IP       

S/W(Logical ≈  Virtual)	 Driver  			    
------------------------------------------------- -------------------- 
H/W(Physical)

  Frame->Packet->Segement로 분해하며 헤더는 버림
  Socket 버퍼에 번호대로 저장함
  Chrome 버퍼에서 소켓버퍼의 값을 Read/Recieve함
  하지만 버퍼간 채움과 비움의 속도 차이가 잇음
     -> 톱니바퀴 처럼 티키타카 잘해야함
  데이터를 손실하지 않기 위해 Socket버퍼의 여유공간이 있어야 함
 
  수신과정에서 TCP가 Packet을 잘 받았으면 ACK이라는 피드백을 해줌
  ACK는 Segment번호와 소켓의 여유공간 정보도 포함됨



Network 장애
  1. Loss (유실) -> 네트워크 상 오류
  2. Re-transmission + ACK-Duplicate ->네트워크 or end-point 오류
	 송신자 입장에서 Ack가 안와서 다시 데이터를 보내줌
	   ->근데 간발의 차로 ACk을 받아버림
 	 수신자 입장에서 ACK를 보냈는데 같은 Segement가 중복하여 옴
  3. Out of Order -> 네트워크상 오류	
	segement의 순서에 맞지 않게 수신함
  4. Zero Window  -> End-point(App)의 문제
	수신측의 소켓버퍼의 여유 공간을 Window Size라 함
             즉, 수신측 소켓버퍼가 꽉찼다는 뜻 
	   -> 프로세스가 소켓버퍼를 못비워줌으로 App 단계 문제



IPV4 헤더 형식

   20byte|        1480byte(경우에 따라 MTU는 0~65535byte까지 증가)
 ----------------------------------------
|	|
|HEADER	|	PAYLOAD
|	|
------------------------------------------

0	4	8		16		32bit        
  Version |    IHL	|	TOS	 |       Total Length               
          Identification		 | Flags | Fragment offset       
  TTL		|   Protocol	 |   Header checksum	  
			Source address(출발지)		| 
			Destination address(목적지)		| 
			Option				|
			Data				|

1행
Version : 4
IHL(Internet Header Length) : 헤더 행의 갯수(주로 5)
	열은 32 bit 임으로 
	->(5*4byte) = 20byte
TOS : 서비스 유형 및 혼잡알림을 나타내는 8bit 필드
Total Length(16bit) -> 0~65535경우의 수

2행 : 단편화와 관련됨 
  단편화 : 네트워크마다 MTU값이 다르기 때문에 크기에 맞춰 자르는것

3행
TTL(8bit) : 패킷 유통과정에서 홉을 만나면 TTL이 값이 줄며 0이되면 버림
Time to live
Protocol : Packet의 payload 내부의 헤더를 해석하는 방법(TCP,UDP)
	고유번호가 존재함
Header checksum : 패킷의 송수신과정에서 손상여부를 검사하는 값



Subnet Mask 
  네트워크 Id와 HostId를 나눠주는 기준
  192	    .168	        .0	          .10
  1100 0000  1010 1000  0000 0000 | 0000 1010(net Mask)
  		bit AND 연산(Mask 연산)
  1111 1111  1111 1111  1111 1111 | 0000 0000 (subnet Mask 값)
		↓
  1100 0000  1010 1000  0000 0000 | 0000 0000 -> hostid 잘림

  패킷이 도착했을때 네트워크 장비가
  넷마스크와 서브넷 마스크연산을 통해 네트워크 id를 확인함
   -> 일치여부로 목적지여부를 판단함

 Host id를 어디까지 볼것이냐에 따른 클래스 기준
 A class .168.0.10 // 255 0 0 0 (서브넷주소) 
 B class  0.10 // 255 255 0 0
 C class .10 //  255 255 255 0
Sub Netting // 255 255 255 192 
	C class 네트워크 방식에서 추가로 쪼갬(나머지 6bit로 hostid)

 -> 하지만 과거방식




CIDR (Classless Inter-Domain Routing)
	192.168.0.10/24
  -> /24를 추가함 (24bit 까지(192.168.0) 네트워크 id라고 표현함)



Broadcast(반대말 : unicast) IP주소 (cf : Mac주소 : 48bit FF-FF-FF-FF
   192.168.0.255
    -> HostId 가 255면 192.168.0 네트워크의 방송 주소가 됨
    -> 192.168.0 에 해당하는 네트워크에 모두 송신 됨
     cf) HostId의 경우 0(서브넷 마스크 결과값),1(주로 게이트웨이가 해당 주 소를 받음),255(Broadcast용 주소)는 못쓰고 253가지 경우의 수만 쓸 수 있음



Host 자신을 가르키는 Ip주소
  동일 컴퓨터의 Process 들끼리 통신이 필요할 때 사용됨
    -> 127.0.0.1 -> Loopback Address(나자신의 주소)
     -> Driver 밑단으로 안가게 해줌

		             ------------------   -------------------
			| Process #1 	Process #2
			| (Client)		(Server)
			|
			-------------------  ------------------		
 	User mode 	|   Socket#1	Socket#2
	----------------------------------------------------------
	Kernel mode	 TCP
			  IP

S/W(Logical ≈  Virtual)	 Driver
-------------------------------------------------- --------------------
H/W(Physical)		

  동일 컴퓨터 내에  Client가 Sever에 접속하려고 할때 == (IPC(Inter process communication) 통신을 할때 )
    Client의 ip주소로 연결하는 것이 아닌 127.0.0.1로 접속함
  cf)  192.168.0.10 변경이 가능한 주소임으로 불안정




Internet
  인터넷은 라우터의 집합체라고 할 수 있는 논리 네트워크이다
    Router ⊂ L3 Switch or L3 Switch ⊂ Router Router == L3 Switch
	     -> 논란의 여지가 있음

  Internet의 핵심 구성요소
    -> Router + DNS

  Packet이 목적지를 찾아가다 길을 잃었다면 삭제해야함(네트워크혼란야기)
  Router1(TTL값 128) -> Router2(TTL값 128)
  |-----------------------------------|
	ㄴHop : 한 라우터에서 다른 라우터로 이동하는 단위




단편화(Fragmentation) 
  단편화는 MTU크기 다름으로 인해 발생함
    -> 1400바이트가 용량한계인 경우 1500은 못받음으로 잘라서 보내야함
  ex) 패킷을 A,B로 나누고 IP헤더를 생성해서
        복사한 B의 Payload값에 붙여줌
    -> 이후 수신측 Ip protocol에서 조립하여 Segment를 꺼냄 
    -> TCP에서 Segment 조립후 Process에 넘겨줌
    
   단편화는 발생하지 않는게 좋음
	-> 송신 과정에서 통과하는 라우터의 MTU중 가장 작은 값에 
                 맞추서 보내 주로 해결함 ->다른 기술도 많음
   단편화는 주로 VPN(IpSec->터널링기술)이 적용되었을 때 발생함




L3 단계에서 인터넷 사용 전에 해야 할 설정
   ISP(internet service provider) 인터넷 제공회사
  1.Host의 식별자가 필요 -> IP주소
  2. Subnet Mask
  3. GateWay Ip주소
  4. DNS 주소
  Ip주소를 자동을 할당 받는 -> DHCP


DHCP(Dynamic(=runtime) Host Configuration Protocol)
  인터넷에 필요한 4가지 설정을 자동으로 해줌
     -> DHCP서버가 알려줌
  특정 Pc가 켜지면 Broadcast packet을 발송함-> DHCP서버를 찾기 위해
  DHCP 서버에는 사용가능한 IP주소를 pool에 저장해놓음
  DHCP 서버는 Broadcast 도메인 안에 있어야됨


ARP(Address Resolution Protocol)
        ㄴIPv4, MAC -> Host의 기본적인 주소
  ARP는 Ip주소로 MAC주소를 알아내려고 할때
  보통 PC를 부팅하면 Gateway MAC주소를 찾아내기 위해
  ARP Request가 발생하고 Reply를 받음(Gateway MAC주소없으면 통신못함)
  
   ex) PC네이버에 접속하려면 Gateway MAC주소를 반드시 알아야함
   cf) Frame의 목적지 주소는 Gateway MAC주소이다(네이버주소아님)
   
    -> ARP 통신후 GATEway MAC주소를 자주 사용하기 때문에 Cashe에 저장해놓고 이후에 또 사용됨 -> cmd arp -a 를 통해 해당 캐쉬 확인가능



Ping과 RTT
  Ping 유틸리티(그냥 프로그램 이름)는  ICMP 프로토콜을 사용하여 특정 Host에 대한 RTT(Round Trip Time)을 측정할 목적으로 사용된다.
  DoS(Denial of Service) 공격용으로 악용되기도 함
  
   RTT는 네트워크 속도에 영향(거리도 어느정도 영향)
   ICMP(internet control message protocol) : 오류 보고 및 네트워크 진단
    				          L3단계에 속함
   cmd -> ping 에서 확인 가능



TCP와 UDP
  식별자 : Port 번호
  TCP에만 연결(Connection, Session) 개념이 있다.
  TCP를 Virtual Circuit이라고도 함
  연결을 결과적으로 순서번호로 구현된다. 
	-> Segement의 번호는 크기에따라 부여함
		1번(400byte) -> 다음번호는 401
  연결은  '상태(전이)' 개념을 동반한다  
     ex) 전화(연결) 전 -> 통화 -> 전화 후
  TCP는 배려남,  		UDP는 나쁜남자에 비유
   ㄴZeroWindow고려해줌     ㄴ 그냥 보냄
  
 기본단위 : TCP(Segement), UDP(Datagram)



TCP 연결 과정 (3-way handshaking)
  TCP 연결은 Seq 번호를 교환, 정책 교환하며 중요한 MSS값도 포함됨
	-> 관리적 정보(Protocol)을 교환함
   Client,서버 중 작은 MSS에 맞춰 Segement를 보냄 
  Segement 단위로 통신되지만 기존 Segement와 달리 IP/TCP헤더만 있음
  1. Client가 서버에 SYN(1000->Sequence number : 연결 요청
  2. 대기중이던 서버가 연결을 확인하면 자기의 Sequence number과 받은 Seq+1을 ACK로 넘겨줌
  3. Client가 서버 Seq +1을 하여 ACK해줌  

 cf)Client가 생각하는 연결완료시점과 Server가 연결된시점이다르다고느낌


TCP 연결 종료과정(4-way handshaking)
  특별한 상황이 아니면 연결,종료는 Client가 요청하게 해야 함
  서버가 Fin+ACk를 받으면 받았다는 ACK를 보내고 종료휴 FIN+ACK를 또 보내줌
  Client가 FIN+ACK를 받으면 Client는 Time_Wait 상태가 되고 마지막 ACK를 보내줌 
 Time wait는 연결 종료 주체에서 발생하며 서버에 Time_wait 상태가 있다면 특수한 상황임을 유추할 수 있음
  Time wait상태로 시간을 보내고 CLOSED 상태가되면서 소켓을 반환함
    ->서버가 종료 요청하면 Client는 Timewait 상태가 될수 없어 소켓의 낭비가 발생할 수 있음
    -> 특수한 상황에서 서버가 종료 요청을 하기 위해서는 Application Protocol 단계에서 특수상황에 대한 구현이 필요함(서버가 Client에게 종료 요청을 유도하는 방식)
